% description of block structure 

% block diagram
\begin{figure}[h]
    \centering
    \input{fig/blockdiag.tex}
    %\captionsetup{justification=centering}
    \caption{Block diagram $\sankalp{Better\ caption?}$}
\label{fig:blockdiag}
\end{figure}

% verilog
\subsection{Verilog Modules}

% wrapper
\subsubsection{Wrapper}


% logic supermodule
\subsubsection{Logical Modules}
\paragraph{Structural Description]}
The logical module for the game consists of a single module that takes inputs from the top level wrapper and outputs the board state to the frame buffer. \newline
The inputs are 
\begin{itemize}
    \item Wire vsync as the clock 
    \item 5 bit wire with Operations
    \item The current framenumber 
\end{itemize}

The outputs are 
\begin{itemize}
    \item A 10x20 array of registers, each 3 bits deep holding the gameboard state
    \item An 8 bit register with the score
    \item A register that holds the gameover state 
\end{itemize}}

Further, there are several interal components 
\begin{itemize}
    \item A 2x4 array of registers, each 5 bits deep tracking the coordinates of the 4 blocks in each Tetrimino
    \item A register storing whether a tetrimino can move more or should be frozen in place
    \item A 3 bit register which acts as a counter to slow the game clock compared vsync \pushkar{Can you think of a better description}
    \item A 3 bit register storing the code of the current tetrimino
\end{itemize}}

\paragraph{Interface}
The instantiation of the module sets all the registers in the boardstate to 0. An initial tetrimino is generated.
\newline 
The gameclock updates at the posedge of vsync. Whenever the gameclock hits the posedge and the game isn't over 
the module performs certain tasks based on the inputs and boardstate
\begin{itemize}
    \item Check whether the current tetrimino is frozen or can move more
    \item If it is frozen, check whether the game is over checking whether any block of the top row is filled
    \item If the game isn't over, delete the rows that are filled, update the score move all rows above down and generate a new tetrimino
    \item If the tetrimino isn't frozen, move it down 
    \item 
\end{itemize}}
We faced issues issues with the syncing of the actions and input due to the relatively low framerate of the clock. 
Therefore evaluating of the inputs is instead done at negedge vsync to prevent inputs 
from being evaluated simultaneously with the above evaluations.

\paragraph{Tetrimino Generation }
The inital block is generated as a L-BLock. 
Every subsequent block is generated based on the framenumber 
at which the generation happens, which ensures sufficient percieved 
randomness using a simple hashing
 \( (Framenumber*PrimeNumber \% 7 +1 \) 
 All of these are generated with one specially identified block
 (Termed by the us as the center of mass) at (5,0) on the gameboard

\paragraph{Motion Control }
4 operations are allowed
\begin{itemize}
    \item Move down
    \item Move left
    \item Move Right
    \item Rotate Clockwise
\end{itemize}}
 A tempory set of coordinates is created based on the current coordinates of the tetrimino and the operation 
 \begin{itemize}
     \item If the operation is to move left, right or down, all the 4 blocks in the tetrimino are moved by 1 block in the appropriate direction
     \item If the operation is to rotate, the center of mass remains constant while the other 3 blocks rotate clockwise by 90 degrees around the center of mass
 \end{itemize}}
 If the operation is found to be valid, the coordinates are updated to
 be equal to the temporary coordinates previously calculated and the boardstate is updated by deleting the blocks at the previous coordinates
 and creating a tetrimino at the new coordinates

\paragraph{Validation }
Two things are checked to see whether a move is valid 
\begin{itemize}
    \item Whether the new position goes beyond the boundary.  As registers cycle back to 0 on going over the maximum 
    value allowed by the but count, this is quite easily done
    by checking  whether the coordinates are greater than 9 and 19 respectively
    \item Whether the new position overlaps with an occupied block. This is done by checking whether the positions at the new coordinates 
    are occupied after removing overlap from the previous and new positions. 
   
\end{itemize}}

% display supermodule
\subsubsection{Display Modules}

\paragraph{VGA Control Module}
\paragraph{Framer Module}
\paragraph{Synchronisation Module}


% c++
\subsection{C++ Wrapper}

In the absence of an FPGA to run described modules, 
we had to look to other options. With a strong desire to 
maintain real-time playability, we tried several options ---
standard simulations had to be rejected due to not being 
anywhere close to real-time, with the inability to accept inputs.
Having considered the idea of running a simulated clock, we then
moved to forcefully driving a clock for the simulation. We attempted
to use \(\texttt{verilog-vga-simulator}\) \cite{vga-simulator},
a C-based program interfacing with the simulation via 
Verilog Procedural Interface (VPI) \cite{vpi}, drawing the resultant
VGA output via Simple DirectMedia Layer \cite{sdl} referred to as 
SDL herein. We were driven away by a cocktail of issues --- primarily
the performance, combined with the relative inflexibility of VPI 
and the now obsolete \cite{sdl_obsolete} SDL API. However, the cocktail
was more than resolvable.

Saving grace came in the form of Verilator \cite{verilator}, a compiler for
Verilog which translates modules top-down into C++ code with
I/O interfaces handled via classes \cite{verilator-implement}. This allowed
us to bypass having to deal with VPI's idiosyncrasies and limited nature, paired
with the finicky fixes required to obtain a realtime driven clock.

Armed with a way to handle inputs and outputs to our modules in realtime, we 
needed a VGA simulator to handle the outputs. This was executed using
SDL2 \cite{sdl2} and a low-level frame-buffer, rendering to screen via 
a cross-platform hardware accelerated rendering interface (with OpenGL \cite{opengl}
primarily used for testing).

However, a software based simulation is unable to drive a clock fast enough
to run a VGA simulation in any of the common modes \cite{vga_modes}. As such,
a myriad of performance-centric changes had to be made. Alongside several
minor optimizations was a major change to the system --- a drastic reduction in
resolution or frame rate. Realistically, keeping the same resolution, the frame 
rate would have been cut to approximately \(\texttt{1/20 fps}\), far from playable.
The resolution would have to be cut similarly to maintain a playable frame rate.
Since most of our clock cycles are used up driving the VGA controller, keeping true
to the design, we chose to downscale it. Outputting a much smaller resolution from
the simulated Verilog modules and writing an integer scaling \cite{intscale} system
within the relatively fast C++ wrapper. 

We would like to add that much higher raw resolution and frame rates are possible 
and have been seen after removing the limitation to output serial VGA. Providing
the frame buffer as output to the display simulator in parallel reduces the time
complexity of drawing a frame from \(\bigO (n^2)\) to \(\bigO (1)\) in screen 
dimensions. However, having achieved desired levels of responsiveness and 
playability without resorting to bending the limits of the FPGA, we chose not 
to do this.